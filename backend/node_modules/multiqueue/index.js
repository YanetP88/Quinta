var add, create, defaults, q, setDefaultInterval, setDefaultLimit, setInterval, setLimit, t, tryNext;

q = {};

defaults = {
  interval: 1000,
  limit: 1
};

t = function() {
  return new Date().getTime();
};

create = function(id, interval, limit) {
  if (q[id] != null) {
    return false;
  }
  if (!isFinite(interval)) {
    interval = defaults.interval;
  }
  if (!isFinite(limit)) {
    limit = defaults.limit;
  }
  if (interval < 1) {
    interval = 1;
  }
  if (limit < 1) {
    limit = 1;
  }
  return q[id] = {
    interval: interval,
    limit: limit,
    timer: null,
    last_called: 0,
    queue: []
  };
};

setInterval = function(newInterval, id) {
  if (id == null) {
    id = 'default';
  }
  if (!isFinite(newInterval || newInterval < 1)) {
    return false;
  }
  return q[id].interval = newInterval;
};

setLimit = function(newLimit, id) {
  if (id == null) {
    id = 'default';
  }
  if (!isFinite(newLimit || newLimit < 1)) {
    return false;
  }
  return q[id].limit = newLimit;
};

setDefaultInterval = function(interval) {
  if (!isFinite(interval || interval < 1)) {
    return;
  }
  return defaults.interval = interval;
};

setDefaultLimit = function(limit) {
  if (!isFinite(limit || limit < 1)) {
    return;
  }
  return defaults.limit = limit;
};

add = function(fn, cb, id) {
  if (id == null) {
    id = 'default';
  }
  if (q[id] == null) {
    create(id);
  }
  q[id].queue.push({
    tries: 0,
    fn: fn,
    cb: cb,
    errors: []
  });
  return tryNext(id);
};

tryNext = function(id) {
  var cb, fn, item, next;
  if (id == null) {
    return false;
  }
  next = q[id].last_called - (t() - q[id].interval);
  if (next > 0) {
    fn = function() {
      return tryNext(id);
    };
    q[id].timer = setTimeout(fn, next);
    return;
  }
  if (q[id].queue.length > 0) {
    item = q[id].queue.splice(0, 1)[0];
    cb = function(err) {
      var a, args, i;
      if (err == null) {
        err = false;
      }
      if (err) {
        item.errors.push(err);
        item.tries++;
        if (item.tries === q[id].limit) {
          return item.cb(item.errors);
        } else {
          q[id].queue.push(item);
          return tryNext(id);
        }
      } else {
        args = (function() {
          var results;
          results = [];
          for (i in arguments) {
            a = arguments[i];
            results.push(a);
          }
          return results;
        }).apply(this, arguments);
        return item.cb.apply(null, args);
      }
    };
    q[id].last_called = t();
    return item.fn.apply({
      queue: {
        id: id,
        length: q[id].queue.length
      },
      tryNo: item.tries + 1
    }, [cb]);
  }
};

create('default');

module.exports = {
  add: add,
  create: create,
  setInterval: setInterval,
  setLimit: setLimit,
  setDefaultInterval: setDefaultInterval,
  setDefaultLimit: setDefaultLimit
};

Object.defineProperty(module.exports, 'queues', {
  get: function() {
    var id, obj;
    obj = {};
    for (id in q) {
      obj[id] = {
        interval: q[id].interval,
        length: q[id].queue.length,
        limit: q[id].limit,
        add: function(fn, cb) {
          return add(fn, cb, id);
        },
        setInterval: function(newInterval) {
          return setInterval(newInterval, id);
        },
        setLimit: function(newLimit) {
          return setLimit(newLimit, id);
        }
      };
    }
    return obj;
  }
});
